# 反混淆：VMP的对抗-0

**提前说清楚：非必要，不建议正面静态还原VMP，耗时耗力。可以通过动态的Trace或者其它的结合方案**。

VMP指的是将代码在一种“虚拟机”上运行。

这是现今反混淆对抗中最难的部分；这部分我也不知道说的对不对；让我来尝试一下进行理论化和流程化吧。

## 正向体系

对抗VMP混淆，首先熟悉一下指令转换的VMP是如何写出来的。

首先，按照现在的团队分工和产品的使用方式；设备指纹，风控算法，请求签名由多个团队协作完成，编写VMP安全保护的团队会对外提供一套编译器插件或者加固工具，将请求签名的算法直接通过编译器生成加固产物，直接融合到应用中。

当然，也有对外销售的，直接加固二进制的VMP工具，可是如果要同步兼顾android/ios/windows等平台，这个投入过大了，不如使用编译器对源码进行保护。

无论如何，一个编译器插件获得编译器的指令选择模块，比如基于LLVM-IR的方案，他的VM架构必须基于已有的LLVM-IR，一定会有mov/add等和常规指令集类似的产物。

## 寻找VM的弱点

也是因为规模问题，重新构造一套完整的 编译 -> 链接 -> 装载 -> 执行 体系是不现实的，工作量太大了。

因此，必须省略其中的部分逻辑，比如VM会直接调用已有libc的组件，省略了装载依赖的问题；或者，VM将所有的指令放到一个文件中，就不用考虑多文件链接的问题。

总之，因为工作量和规模的问题，分析一个VM首先要找到他的薄弱点.



## 动态trace+调试VM



## 静态+动静态结合



## 完美分析
