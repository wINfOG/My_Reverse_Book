# 7. 变量还原：反编译与还原

在反编译的体系中，变量的还原从来不是某个独立阶段的任务，而是各个阶段或多或少都会参与一部分。

最后在展示的时候，进行一轮的汇总。

其中最为关键的部分在之前已经描述过，即从汇编中对于寄存器+内存+栈对象的操作转换为SSA形态的IR语句。

然后，SSA语句中端经历了各种的优化pass逻辑，形成了最终的形态。这样，反编译器的变量还原逻辑，就可以直接使用完成优化后的SSA；是的，不做太多的处理直接使用SSA的形式中的变量。

## 直接优化SSA作为结果

直接使用SSA作为方案的变量结果，只需要解决phi函数中的变量合并即可（毕竟正常的代码里不会有phi函数）。

通常，处理的方法也和朴素，直接在每个block的结尾添加一个变量赋值语句，将phi结果的变量赋值过去就好。

```
void test(bool xx) {
    int a_phi;
    //前面省略
    if (xx == True) {
        a_1 = 1;
    } else if (xx == False) {
        a_2 = 2;
    }
    a_phi = phi(a_1, a_2)
    // 后续省略
}
```

经过分配后的处理，就会将phi函数给捋平了，然后分类到每个函数中去。

```
void test(bool xx) {
    int a_phi;
    //前面省略
    if (xx == True) {
        a_1 = 1;
        a_phi = a_1;
    } else if (xx == False) {
        a_2 = 2;
        a_phi = a_1;
    }
    // 后续省略
}
```

但是，这也有明显的缺陷，能感觉到代码的可读性变差了；因为明显的多了两次没必要的赋值语句。

例如，binary-ninja中就是典型这样做的，虽然会有一部分的优化，但是下面图中的很明显的X8\_2和X8的赋值逻辑会有很多次。

<figure><img src="../.gitbook/assets/image (2).png" alt=""><figcaption></figcaption></figure>

## 不使用SSA的方法



